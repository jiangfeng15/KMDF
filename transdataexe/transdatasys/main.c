#include <ntddk.h>

#include "clt_code.h"

#define INITCODE code_seg("INIT");
#define PAGECODE code_seg("PAGE");

NTSTATUS CreateMyDevice(IN PDRIVER_OBJECT pDriverObject)
{
	NTSTATUS status;
	UNICODE_STRING devName;  //设备名称
	UNICODE_STRING sysLinkName;  //系统符号链接名
	PDEVICE_OBJECT pDevObject;    //用于返回创建设备
	
	RtlInitUnicodeString(&devName, L"\\Device\\MyDevObj");
	status = IoCreateDevice(pDriverObject, 0, &devName, FILE_DEVICE_UNKNOWN, 0, TRUE, &pDevObject);
	if (!NT_SUCCESS(status))
	{
		if (status == STATUS_INSUFFICIENT_RESOURCES)
		{
			KdPrint(("资源不足\n"));
		}
		if (status == STATUS_OBJECT_NAME_EXISTS)
		{
			KdPrint(("指定对象名存在\n"));
		}
		if (status == STATUS_OBJECT_NAME_COLLISION)
		{
			KdPrint(("对象名有冲突"));
		}
		return status;
	}
	KdPrint(("设备创建成功\n"));
	pDevObject->Flags |= DO_BUFFERED_IO; //缓冲区方式读写
	RtlInitUnicodeString(&sysLinkName, L"\\??\\MySysData");
	IoDeleteSymbolicLink(&sysLinkName);
	status = IoCreateSymbolicLink(&sysLinkName, &devName); //判断生成符号链接是否成功
	if (!NT_SUCCESS(status))
	{
		KdPrint(("生成符号链接失败\n"));
		IoDeleteDevice(pDevObject);
		return status;
	}
	KdPrint(("生成符号链接成功"));

	return STATUS_SUCCESS;
}

VOID DriverUnload(PDRIVER_OBJECT pDriverObject)
{
	PDEVICE_OBJECT pDevObject;
	UNICODE_STRING sysLinkName;

	pDevObject = pDriverObject->DeviceObject;
	IoDeleteDevice(pDevObject);	//取得设备并删除
	KdPrint(("成功删除设备\n"));

	RtlInitUnicodeString(&sysLinkName, L"\\??\\MySysData");
	IoDeleteSymbolicLink(&sysLinkName);	//取得符号链接并删除
	KdPrint(("成功删除符号链接\n"));

	KdPrint(("驱动成功卸载\n"));
}


//NTSTATUS MyDispatchRoutine(IN PDEVICE_OBJECT pDevobj, IN PIRP pIrp)
//{
//	return STATUS_SUCCESS;
//}


NTSTATUS MyDispatchRoutine(IN PDEVICE_OBJECT pDevobj, IN PIRP pIrp)
{
	ULONG info;
	PIO_STACK_LOCATION psl = IoGetCurrentIrpStackLocation(pIrp);

	switch (psl->MajorFunction)
	{
		case IRP_MJ_CREATE:
			KdPrint(("exe Create file"));
			break;
		case IRP_MJ_CLOSE:
			KdPrint(("exe Close file"));
			break;
		case IRP_MJ_READ:
			break;
		case IRP_MJ_WRITE:
			break;
		case IRP_MJ_DEVICE_CONTROL:
		{
			//判断是否为32位进程
			if (IoIs32bitProcess(pIrp))
			{
				KdPrint(("调用应用为 32 位"));
			}
			else
			{
				KdPrint(("调用应用为 64 位"));
			}
			NTSTATUS status = STATUS_SUCCESS;
			ULONG cbin = psl->Parameters.DeviceIoControl.InputBufferLength; //获取输入缓冲区大小
			ULONG cbout = psl->Parameters.DeviceIoControl.OutputBufferLength; //获取输出缓冲区大小
			ULONG code = psl->Parameters.DeviceIoControl.IoControlCode; //得到IOCTL
			KdPrint(("Enter IRP_MJ_DEVICE_CONTROL\n"));
			switch (code)
			{
			case add_code:
			{
				int a, b, r;
				int * inputBuffer = (int*)pIrp->AssociatedIrp.SystemBuffer;
				int * outBuffer = (int *)pIrp->AssociatedIrp.SystemBuffer;
				KdPrint(("Enter add_code\n"));
				a = *inputBuffer;
				b = *(inputBuffer + 1);
				//_asm {							//汇编方式取出a,b值,等价于a = *inputBuffer; b = *(inputBuffer+1);
				//	mov eax, inputBuffer
				//	mov ebx, [eax]
				//	mov a, ebx
				//	mov ebx, [eax + 4]
				//	mov b, ebx
				//}
				KdPrint(("a=%d, b=%d\n", a, b));
				r = a + b;
				*outBuffer = r;
				//_asm {							//汇编方式保存r值,等价于*inputBuffer = r;
				//	mov eax, r
				//	mov ebx, outputBuffer
				//	mov[ebx], eax
				//}
				KdPrint(("a+b=%d\n", r));
				info = 4;
				break;
			}
			case sub_code:
			{
				break;
			}

			}
		}
		default:
		{
			KdPrint(("其它处理"));
			break;
		}
	}

	pIrp->IoStatus.Information = info;			//设置操作的字节数为0，这里无实际意义
	pIrp->IoStatus.Status = STATUS_SUCCESS;		//返回成功
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);	//指示完成此IRP
	KdPrint(("离开派遣函数\n"));				//调试信息
	return STATUS_SUCCESS;
}
#pragma INITCODE
NTSTATUS DriverEntry(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING reg_path)
{
	KdPrint(("驱动加载成功\n"));
	pDriverObject->MajorFunction[IRP_MJ_CREATE] = MyDispatchRoutine;
	pDriverObject->MajorFunction[IRP_MJ_CLOSE] = MyDispatchRoutine;
	pDriverObject->MajorFunction[IRP_MJ_READ] = MyDispatchRoutine;
	pDriverObject->MajorFunction[IRP_MJ_WRITE] = MyDispatchRoutine;
	pDriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = MyDispatchRoutine;
	CreateMyDevice(pDriverObject);
	pDriverObject->DriverUnload = DriverUnload;
	return STATUS_SUCCESS;
}